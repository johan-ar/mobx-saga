{"mappings":"2OA0FgBA,EAAaC,EAAcC,GACzC,IAAIC,EAuBJ,OApBEA,EADED,EACW,EACVD,MAASG,GACR,MAAMC,EAASH,KAAiBE,GAEhC,OADAC,EAAOJ,KAAOA,EACPI,IAETJ,GAEW,EACVA,GAAMK,IACE,MAAEL,UAAMK,KAEjBL,GAGJE,EAAcF,KAAOA,EACrBE,EAAcI,SAAQ,IAASN,EAC/BE,EAAcK,MAASH,GACrBA,EAAOJ,OAASA,EAEXE,wCCjFOM,EAAkBC,GAChC,MAAMC,EAAUD,EAAQC,SAAWC,IAE7BC,EAAM,CAAIC,KAA0BV,IACjCW,GAAW,IAAYD,EAASJ,EAAQM,SAAUZ,KAGrDa,EAAmC,SACvCN,EACAO,UAAWZ,SAAUQ,SAACA,EAAQV,KAAEA,KAC9BS,EAAOC,KAAaV,IAEtBe,SAAQ,IACCT,EAAQM,MAEjBI,YAAaV,EAAQW,SAGvB,MAAO,QACLR,UACAF,EACAO,SAAUP,EAAQW,IAClBC,IAAG,CAACC,KAAapB,IACRqB,EAAQR,EAAIO,KAAapB,4CCzCtBsB,EACdZ,KACGV,GAEH,OAAOuB,EAAI,CACT1B,KAAI,aAAea,EAASc,MAAQ,MACpCtB,QAAS,UAAEQ,OAAUV","sources":["mobx-saga/src/createAction.ts","mobx-saga/src/createMobXSaga.ts","mobx-saga/src/mutate.ts"],"sourcesContent":["import { A } from \"ts-toolbelt\";\n\nexport type NonUndefined<T> = Exclude<T, undefined | null | void>;\n\nexport type ActionExtension<O> = O extends void\n  ? {}\n  : A.Compute<Omit<O, \"type\" | \"payload\">, \"flat\">;\n\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  Ex extends { [k: string]: any } = never\n> = [Ex] extends [never]\n  ? {\n      type: T;\n      payload: P;\n    }\n  : {\n      type: T;\n      payload: P;\n    } & ActionExtension<Ex>;\n\nexport interface Action<T extends string = string> {\n  type: T;\n}\n\nexport interface AnyAction extends Action {\n  [key: string | number | symbol]: any;\n}\n\nexport interface BaseActionCreator<P, T extends string = string>\n  extends Action<T> {\n  toString(): T;\n  match(action: AnyAction): action is PayloadAction<P, T>;\n}\n\nexport interface ActionCreatorWithoutPayload<T extends string = string>\n  extends BaseActionCreator<undefined, T> {\n  (): PayloadAction<undefined, T>;\n}\n\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\n  extends BaseActionCreator<P | undefined, T> {\n  (payload?: P): PayloadAction<P | undefined, T>;\n}\n\nexport interface ActionCreatorWithPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  (payload: P): PayloadAction<P, T>;\n}\n\nexport interface ActionCreatorWithPreparedPayload<\n  PA extends PrepareAction<any>,\n  T extends string\n> extends BaseActionCreator<ReturnType<PA>[\"payload\"], T> {\n  (...args: Parameters<PA>): PayloadAction<\n    ReturnType<PA>[\"payload\"],\n    T,\n    ReturnType<PA>\n  >;\n}\n\n// prettier-ignore\nexport type ActionCreator<\n  P = undefined,\n  T extends string = string,\n  PA extends PrepareAction<any> | void = void\n> =\n  PA extends PrepareAction<any> ?\n      ActionCreatorWithPreparedPayload<PA, T>\n  : A.Is<P, undefined, 'equals'> extends 1 ?\n      ActionCreatorWithoutPayload<T>\n  : A.Is<P, undefined, '<-contains'> extends 1 ?\n      ActionCreatorWithOptionalPayload<NonUndefined<P>, T>\n  : ActionCreatorWithPayload<P, T>;\n\ntype PrepareAction<P> = (...args: any[]) => {\n  payload: P;\n  [K: string | symbol | number]: any;\n};\n\nexport function createAction<P = undefined, T extends string = string>(\n  type: T\n): ActionCreator<P, T, void>;\n\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(type: T, prepareAction: PA): ActionCreator<ReturnType<PA>[\"payload\"], T, PA>;\n\nexport function createAction(type: string, prepareAction?: PrepareAction<any>) {\n  let actionCreator;\n\n  if (prepareAction) {\n    actionCreator = <ActionCreator<any, string, PrepareAction<any>>>{\n      [type](...args: any[]) {\n        const action = prepareAction(...args);\n        action.type = type;\n        return action;\n      },\n    }[type];\n  } else {\n    actionCreator = <ActionCreator<any, string>>{\n      [type](payload?: any) {\n        return { type, payload };\n      },\n    }[type];\n  }\n\n  actionCreator.type = type;\n  actionCreator.toString = () => type;\n  actionCreator.match = (action: AnyAction): action is PayloadAction<any> =>\n    action.type === type;\n\n  return actionCreator;\n}\n","import {\n  MulticastChannel,\n  runSaga,\n  RunSagaOptions,\n  SagaMonitor,\n  stdChannel,\n} from \"@redux-saga/core\";\nimport { Saga, Task } from \"@redux-saga/types\";\nimport { runInAction } from \"mobx\";\nimport { L } from \"ts-toolbelt\";\nimport { Mutation, PayloadMutation } from \".\";\nimport { AnyAction } from \"./createAction\";\n\nexport type SagaDispatcher<A extends AnyAction = AnyAction> = (\n  action: A\n) => void;\n\nexport type MobXSagaOptions<T> = {\n  store: T;\n  monitor?: SagaMonitor;\n  channel?: MulticastChannel<AnyAction>;\n};\n\nexport type MobXSaga<T> = {\n  run<S extends Saga>(main: S, ...args: Parameters<S>): Task;\n  dispatch: SagaDispatcher;\n  commit<M extends Mutation<T>>(\n    mutation: M,\n    ...args: L.Tail<Parameters<M>>\n  ): ReturnType<M>;\n  channel: MulticastChannel<AnyAction>;\n};\n\nexport function createMobXSaga<T>(options: MobXSagaOptions<T>): MobXSaga<T> {\n  const channel = options.channel || stdChannel();\n\n  const commit = (mutation: Mutation<T>, ...args: any[]) => {\n    return runInAction<any>(() => mutation(options.store, ...args));\n  };\n\n  const io: RunSagaOptions<AnyAction, T> = {\n    channel,\n    dispatch({ payload: { mutation, args } }: PayloadMutation) {\n      commit(mutation, ...args);\n    },\n    getState() {\n      return options.store;\n    },\n    sagaMonitor: options.monitor,\n  };\n\n  return {\n    commit,\n    channel,\n    dispatch: channel.put,\n    run(mainSaga, ...args) {\n      return runSaga(io, mainSaga, ...args);\n    },\n  };\n}\n","import { put, PutEffect } from \"redux-saga/effects\";\nimport { L } from \"ts-toolbelt\";\nimport { PayloadAction } from \".\";\n\nexport type Mutation<T, Args extends any[] = any[]> = (\n  rootStore: T,\n  ...args: Args\n) => any;\n\nexport type PayloadMutation<M extends Mutation<any> = Mutation<any>> =\n  PayloadAction<\n    { mutation: M; args: L.Tail<Parameters<M>> },\n    `@mutation/${string}`\n  >;\n\nexport function commit<M extends Mutation<any>>(\n  mutation: M,\n  ...args: L.Tail<Parameters<M>>\n): PutEffect<PayloadMutation<M>> {\n  return put({\n    type: `@mutation/${mutation.name || \"_\"}`,\n    payload: { mutation, args },\n  });\n}\n\ntype RootStore = { value: number };\n\nconst inc = (store: RootStore, inc: number) => {\n  store.value = inc;\n};\n\nfunction* doSaga() {\n  yield commit(inc, 1);\n  yield commit((store: RootStore, n: number) => {\n    store.value += n;\n  }, 1);\n}\n"],"names":["$13783ec5ef2a9e47$export$309c7a02b0b0bc62","type","prepareAction","actionCreator","args","action","payload","toString","match","$892c03dedbd7c7b8$export$4e7cd27c79410e7f","options","channel","$6OgbA$stdChannel","commit","mutation","$6OgbA$runInAction","store","io","dispatch","getState","sagaMonitor","monitor","put","run","mainSaga","$6OgbA$runSaga","$efb6c5331c6a3e7c$export$c25eba0b6986e3d5","$6OgbA$put","name"],"version":3,"file":"index.mjs.map"}