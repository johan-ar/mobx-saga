{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;SCsFgB,yCAAY,CAAC,IAAY,EAAE,aAAkC,EAAE,CAAC;IAC9E,GAAG,CAAC,aAAa;IAEjB,EAAE,EAAE,aAAa,EACf,aAAa,IAAuB,CAAC;SAClC,IAAI,MAAK,IAAI,EAAS,CAAC;YACtB,KAAK,CAAC,MAAM,GAAG,aAAa,IAAI,IAAI;YACpC,MAAM,CAAC,IAAI,GAAG,IAAI;YAClB,MAAM,CAAC,MAAM;QACf,CAAC;IACH,CAAC,EAAC,IAAI;SAEN,aAAa,IAAuB,CAAC;SAClC,IAAI,GAAE,OAAa,EAAE,CAAC;YACrB,MAAM,CAAC,CAAC;sBAAC,IAAI;yBAAE,OAAO;YAAC,CAAC;QAC1B,CAAC;IACH,CAAC,EAAC,IAAI;IAGR,aAAa,CAAC,IAAI,GAAG,IAAI;IACzB,aAAa,CAAC,QAAQ,OAAS,IAAI;;IACnC,aAAa,CAAC,KAAK,IAAI,MAAiB,GACtC,MAAM,CAAC,IAAI,KAAK,IAAI;;IAEtB,MAAM,CAAC,aAAa;AACtB,CAAC;;;;;;;;SCnFe,yCAAc,CAAI,OAA2B,EAAY,CAAC;IACxE,KAAK,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,+BAAU;IAE7C,KAAK,CAAC,EAAE,GAAiC,CAAC;iBACxC,OAAO;QACP,QAAQ,EAAC,MAAkC,EAAE,CAAC;YAC5C,uBAAW,KAAO,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK;;QAChD,CAAC;QACD,QAAQ,IAAG,CAAC;YACV,MAAM,CAAC,OAAO,CAAC,KAAK;QACtB,CAAC;QACD,WAAW,EAAE,OAAO,CAAC,OAAO;IAC9B,CAAC;IAED,MAAM,CAAC,CAAC;iBACN,OAAO;QACP,QAAQ,EAAE,OAAO,CAAC,GAAG;QACrB,GAAG,EAAC,QAAQ,KAAK,IAAI,EAAE,CAAC;YACtB,MAAM,CAAC,4BAAO,CAAC,EAAE,EAAE,QAAQ,KAAK,IAAI;QACtC,CAAC;IACH,CAAC;AACH,CAAC;;;;;;;SC5Ce,yCAAM,CACpB,QAAqB,EACyC,CAAC;IAC/D,MAAM,CAAC,2BAAG,CAAC,CAAC;QAAC,IAAI,GAAG,UAAU,EAAE,QAAQ,CAAC,IAAI,IAAI,CAAG;QAAI,OAAO,EAAE,QAAQ;IAAC,CAAC;AAC7E,CAAC;","sources":["mobx-saga/src/index.ts","mobx-saga/src/createAction.ts","mobx-saga/src/createMobXSaga.ts","mobx-saga/src/mutate.ts"],"sourcesContent":["export * from \"./createAction\";\nexport * from \"./createMobXSaga\";\nexport * from \"./mutate\";\n","import { A } from \"ts-toolbelt\";\n\nexport type NonUndefined<T> = Exclude<T, undefined | null | void>;\n\nexport type ActionExtension<O> = O extends void\n  ? {}\n  : A.Compute<Omit<O, \"type\" | \"payload\">, \"flat\">;\n\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  Ex extends { [k: string]: any } = never\n> = [Ex] extends [never]\n  ? {\n      type: T;\n      payload: P;\n    }\n  : {\n      type: T;\n      payload: P;\n    } & ActionExtension<Ex>;\n\nexport interface Action<T extends string = string> {\n  type: T;\n}\n\nexport interface AnyAction extends Action {\n  [key: string | number | symbol]: any;\n}\n\nexport interface BaseActionCreator<P, T extends string = string>\n  extends Action<T> {\n  toString(): T;\n  match(action: AnyAction): action is PayloadAction<P, T>;\n}\n\nexport interface ActionCreatorWithoutPayload<T extends string = string>\n  extends BaseActionCreator<undefined, T> {\n  (): PayloadAction<undefined, T>;\n}\n\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\n  extends BaseActionCreator<P | undefined, T> {\n  (payload?: P): PayloadAction<P | undefined, T>;\n}\n\nexport interface ActionCreatorWithPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  (payload: P): PayloadAction<P, T>;\n}\n\nexport interface ActionCreatorWithPreparedPayload<\n  T extends string,\n  PA extends PrepareAction<any>\n> extends BaseActionCreator<ReturnType<PA>[\"payload\"], T> {\n  (...args: Parameters<PA>): PayloadAction<\n    ReturnType<PA>[\"payload\"],\n    T,\n    ReturnType<PA>\n  >;\n}\n\n// prettier-ignore\nexport type ActionCreator<P, T extends string = string, PA = void> =\n  PA extends PrepareAction<any> ?\n      ActionCreatorWithPreparedPayload<T, PA>\n  : [P] extends [undefined] ?\n      ActionCreatorWithoutPayload<T>\n  : [undefined] extends [P] ?\n      ActionCreatorWithOptionalPayload<NonUndefined<P>, T>\n  : ActionCreatorWithPayload<P, T>;\n\ntype PrepareAction<P> = (...args: any[]) => {\n  payload: P;\n  [K: string | symbol | number]: any;\n};\n\nexport function createAction<P = undefined, T extends string = string>(\n  type: T\n): ActionCreator<P, T>;\n\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(type: T, prepareAction: PA): ActionCreator<ReturnType<PA>[\"payload\"], T, PA>;\n\nexport function createAction(type: string, prepareAction?: PrepareAction<any>) {\n  let actionCreator;\n\n  if (prepareAction) {\n    actionCreator = <ActionCreator<any>>{\n      [type](...args: any[]) {\n        const action = prepareAction(...args);\n        action.type = type;\n        return action;\n      },\n    }[type];\n  } else {\n    actionCreator = <ActionCreator<any>>{\n      [type](payload?: any) {\n        return { type, payload };\n      },\n    }[type];\n  }\n\n  actionCreator.type = type;\n  actionCreator.toString = () => type;\n  actionCreator.match = (action: AnyAction): action is PayloadAction<any> =>\n    action.type === type;\n\n  return actionCreator;\n}\n","import {\n  MulticastChannel,\n  runSaga,\n  RunSagaOptions,\n  SagaMonitor,\n  stdChannel,\n} from \"@redux-saga/core\";\nimport { Saga, Task } from \"@redux-saga/types\";\nimport { runInAction } from \"mobx\";\nimport { AnyAction, PayloadAction } from \"./createAction\";\nimport { Mutation } from \"./mutate\";\n\nexport type SagaDispatcher<A extends AnyAction = AnyAction> = (\n  action: A\n) => void;\n\nexport type MobXSagaOptions<T> = {\n  store: T;\n  monitor?: SagaMonitor;\n  channel?: MulticastChannel<AnyAction>;\n};\n\nexport type MobXSaga = {\n  run<S extends Saga>(main: S, ...args: Parameters<S>): Task;\n  dispatch: SagaDispatcher;\n  channel: MulticastChannel<AnyAction>;\n};\n\nexport function createMobXSaga<T>(options: MobXSagaOptions<T>): MobXSaga {\n  const channel = options.channel || stdChannel();\n\n  const io: RunSagaOptions<AnyAction, T> = {\n    channel,\n    dispatch(action: PayloadAction<Mutation<T>>) {\n      runInAction(() => action.payload(options.store));\n    },\n    getState() {\n      return options.store;\n    },\n    sagaMonitor: options.monitor,\n  };\n\n  return {\n    channel,\n    dispatch: channel.put,\n    run(mainSaga, ...args) {\n      return runSaga(io, mainSaga, ...args);\n    },\n  };\n}\n","import { put, PutEffect } from \"redux-saga/effects\";\nimport { PayloadAction } from \".\";\n\nexport type Mutation<T> = (rootStore: T) => any;\n\nexport function mutate<T>(\n  mutation: Mutation<T>\n): PutEffect<PayloadAction<Mutation<T>, `@mutation/${string}`>> {\n  return put({ type: `@mutation/${mutation.name || \"_\"}`, payload: mutation });\n}\n"],"names":[],"version":3,"file":"index.js.map"}