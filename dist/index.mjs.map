{"mappings":"2OA8FgBA,EAAaC,EAAcC,GACzC,IAAIC,EA4BJ,OAzBEA,EADED,EACW,EACVD,MAASG,GACR,MAAMC,EAASH,KAAiBE,GAEhC,MAAO,CACLH,KAAMA,EACNK,QAASD,EAAOC,WACZ,SAAUD,GAAU,CAAEE,KAAMF,EAAOE,SACnC,UAAWF,GAAU,CAAEE,KAAMF,EAAOG,UAG5CP,GAEW,EACVA,GAAMK,IACE,MAAEL,UAAMK,KAEjBL,GAGJE,EAAcF,KAAOA,EACrBE,EAAcM,SAAQ,IAASR,EAC/BE,EAAcO,MAASL,GACrBA,EAAOJ,OAASA,EAEXE,wCC1FOQ,EAAkBC,GAChC,MAAMC,EAAUD,EAAQC,SAAWC,IAE7BC,EAAM,CAAIC,KAA0BZ,IACjCa,GAAW,IAAYD,EAASJ,EAAQM,SAAUd,KAGrDe,EAAmC,SACvCN,EACAO,UAAWd,SAAUU,SAACA,EAAQZ,KAAEA,KAC9BW,EAAOC,KAAaZ,IAEtBiB,SAAQ,IACCT,EAAQM,MAEjBI,YAAaV,EAAQW,SAGvB,MAAO,QACLR,UACAF,EACAO,SAAUP,EAAQW,IAClBC,IAAG,CAACC,KAAatB,IACRuB,EAAQR,EAAIO,KAAatB,4CCzCtBwB,EACdZ,KACGZ,GAEH,OAAOyB,EAAI,CACT5B,KAAI,aAAee,EAASc,MAAQ,MACpCxB,QAAS,UAAEU,OAAUZ","sources":["mobx-saga/src/createAction.ts","mobx-saga/src/createMobXSaga.ts","mobx-saga/src/mutate.ts"],"sourcesContent":["import { A } from \"ts-toolbelt\";\n\nexport type NonUndefined<T> = Exclude<T, undefined | null | void>;\n\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  M = never,\n  E = never\n> = {\n  type: T;\n  payload: P;\n} & ([M] extends [never] ? {} : { meta: M }) &\n  ([E] extends [never] ? {} : { error: E });\n\nexport interface Action<T extends string = string> {\n  type: T;\n}\n\nexport interface AnyAction extends Action {\n  [key: string | number | symbol]: any;\n}\n\nexport interface BaseActionCreator<P, T extends string = string>\n  extends Action<T> {\n  toString(): T;\n  match(action: AnyAction): action is PayloadAction<P, T>;\n}\n\nexport interface ActionCreatorWithoutPayload<T extends string = string>\n  extends BaseActionCreator<undefined, T> {\n  (): PayloadAction<undefined, T>;\n}\n\nexport interface ActionCreatorWithOptionalPayload<P, T extends string = string>\n  extends BaseActionCreator<P | undefined, T> {\n  (payload?: P): PayloadAction<P | undefined, T>;\n}\n\nexport interface ActionCreatorWithPayload<P, T extends string = string>\n  extends BaseActionCreator<P, T> {\n  (payload: P): PayloadAction<P, T>;\n}\n\nexport type ActionCreatorWithPreparedPayloadHelper<\n  PA extends PrepareAction<any>,\n  T extends string\n> = ActionCreatorWithPreparedPayload<\n  ReturnType<PA> extends { payload: infer P } ? P : never,\n  T,\n  Parameters<PA>,\n  ReturnType<PA> extends { meta: infer M } ? M : never,\n  ReturnType<PA> extends { error: infer E } ? E : never\n>;\n\nexport interface ActionCreatorWithPreparedPayload<\n  P,\n  T extends string = string,\n  Args extends any[] = any[],\n  M = never,\n  E = never\n> extends BaseActionCreator<P, T> {\n  (...args: Args): PayloadAction<P, T, M, E>;\n}\n\n// prettier-ignore\nexport type ActionCreator<\n  P = undefined,\n  T extends string = string,\n  PA extends PrepareAction<any> | void = void\n> =\n  PA extends PrepareAction<any> ?\n      ActionCreatorWithPreparedPayloadHelper<PA, T>\n  : A.Is<P, undefined, 'equals'> extends 1 ?\n      ActionCreatorWithoutPayload<T>\n  : A.Is<P, undefined, '<-contains'> extends 1 ?\n      ActionCreatorWithOptionalPayload<NonUndefined<P>, T>\n  : ActionCreatorWithPayload<P, T>;\n\nexport type PrepareAction<P> = (...args: any[]) => {\n  payload: P;\n  meta?: any;\n  error?: any;\n};\n\nexport function createAction<P = undefined, T extends string = string>(\n  type: T\n): ActionCreator<P, T, void>;\n\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(type: T, prepareAction: PA): ActionCreator<ReturnType<PA>[\"payload\"], T, PA>;\n\nexport function createAction(type: string, prepareAction?: PrepareAction<any>) {\n  let actionCreator;\n\n  if (prepareAction) {\n    actionCreator = <ActionCreator<any, string, PrepareAction<any>>>{\n      [type](...args: any[]) {\n        const action = prepareAction(...args);\n\n        return {\n          type: type,\n          payload: action.payload,\n          ...(\"meta\" in action && { meta: action.meta }),\n          ...(\"error\" in action && { meta: action.error }),\n        };\n      },\n    }[type];\n  } else {\n    actionCreator = <ActionCreator<any, string>>{\n      [type](payload?: any) {\n        return { type, payload };\n      },\n    }[type];\n  }\n\n  actionCreator.type = type;\n  actionCreator.toString = () => type;\n  actionCreator.match = (action: AnyAction): action is PayloadAction<any> =>\n    action.type === type;\n\n  return actionCreator;\n}\n","import {\n  MulticastChannel,\n  runSaga,\n  RunSagaOptions,\n  SagaMonitor,\n  stdChannel,\n} from \"@redux-saga/core\";\nimport { Saga, Task } from \"@redux-saga/types\";\nimport { runInAction } from \"mobx\";\nimport { L } from \"ts-toolbelt\";\nimport { Mutation, PayloadMutation } from \".\";\nimport { AnyAction } from \"./createAction\";\n\nexport type SagaDispatcher<A extends AnyAction = AnyAction> = (\n  action: A\n) => void;\n\nexport type MobXSagaOptions<T> = {\n  store: T;\n  monitor?: SagaMonitor;\n  channel?: MulticastChannel<AnyAction>;\n};\n\nexport type MobXSaga<T> = {\n  run<S extends Saga>(main: S, ...args: Parameters<S>): Task;\n  dispatch: SagaDispatcher;\n  commit<M extends Mutation<T>>(\n    mutation: M,\n    ...args: L.Tail<Parameters<M>>\n  ): ReturnType<M>;\n  channel: MulticastChannel<AnyAction>;\n};\n\nexport function createMobXSaga<T>(options: MobXSagaOptions<T>): MobXSaga<T> {\n  const channel = options.channel || stdChannel();\n\n  const commit = (mutation: Mutation<T>, ...args: any[]) => {\n    return runInAction<any>(() => mutation(options.store, ...args));\n  };\n\n  const io: RunSagaOptions<AnyAction, T> = {\n    channel,\n    dispatch({ payload: { mutation, args } }: PayloadMutation) {\n      commit(mutation, ...args);\n    },\n    getState() {\n      return options.store;\n    },\n    sagaMonitor: options.monitor,\n  };\n\n  return {\n    commit,\n    channel,\n    dispatch: channel.put,\n    run(mainSaga, ...args) {\n      return runSaga(io, mainSaga, ...args);\n    },\n  };\n}\n","import { put, PutEffect } from \"redux-saga/effects\";\nimport { L } from \"ts-toolbelt\";\nimport { PayloadAction } from \".\";\n\nexport type Mutation<T, Args extends any[] = any[]> = (\n  rootStore: T,\n  ...args: Args\n) => any;\n\nexport type PayloadMutation<M extends Mutation<any> = Mutation<any>> =\n  PayloadAction<\n    { mutation: M; args: L.Tail<Parameters<M>> },\n    `@mutation/${string}`\n  >;\n\nexport function commit<M extends Mutation<any>>(\n  mutation: M,\n  ...args: L.Tail<Parameters<M>>\n): PutEffect<PayloadMutation<M>> {\n  return put({\n    type: `@mutation/${mutation.name || \"_\"}`,\n    payload: { mutation, args },\n  });\n}\n"],"names":["$13783ec5ef2a9e47$export$309c7a02b0b0bc62","type","prepareAction","actionCreator","args","action","payload","meta","error","toString","match","$892c03dedbd7c7b8$export$4e7cd27c79410e7f","options","channel","$6OgbA$stdChannel","commit","mutation","$6OgbA$runInAction","store","io","dispatch","getState","sagaMonitor","monitor","put","run","mainSaga","$6OgbA$runSaga","$efb6c5331c6a3e7c$export$c25eba0b6986e3d5","$6OgbA$put","name"],"version":3,"file":"index.mjs.map"}